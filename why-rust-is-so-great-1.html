<!DOCTYPE html>
<html lang="en">
  <link type="application/atom+xml" rel="alternate" href="https://mikehentges.github.io/feed.xml" title="Michael Hentges Blog" />
  <head>
    <!-- Styles-->
    <link rel="stylesheet" href="/assets/css/styles.css" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="monetization" content="$ilp.uphold.com/3kikPPEakjxe" />
    <title>Michael Hentges Blog</title>
  </head>

  <body>
    <!-- This is our header. -->

<header>
    <link rel="icon" type="image/x-icon" href="/logo-color.ico">

    <div class="header_title">Michael Hentges Blog</div>
    <div class="header_menu">
        <ul>
            <li><a href="/">Home</a></li>
            
            
                <li><a href="/ai">AI</a></li>
            
                <li><a href="/programming">Programming</a></li>
            
                <li><a href="/chess">Chess</a></li>
            
                <li><a href="/woodworking">Woodworking</a></li>
            
            <li><a href="/about">About</a></li>
        </ul>
    </div>
    
</header> <section class="post-section">
    <link type="application/atom+xml" rel="alternate" href="https://mikehentges.github.io/feed.xml" title="Michael Hentges Blog" />

    
    <img class="hero" src="https://res.cloudinary.com/dbzsk4ytb/image/upload/c_scale,w_720/v1667997352/blog-images/Rust-is-Great/Great_rgfa03.jpg">
    
    
    
    <h2>Why Rust is so Great – Reason 1, The Borrow Checker</h2>
    
    <p>Nov 09, 2022</p>

    <p>When I first tripped across Rust, it was through an article touting Rust’s election as the “most loved programming language” for several years in Stack overflow’s yearly survey (https://survey.stackoverflow.co/2022/#technology-most-loved-dreaded-and-wanted).</p>

<p>The high-level language description was interesting – compiled, no virtual machine, efficient, fast, and safe. I’ll admit a bias towards compiled and type-safe languages – I grew up on C, have taught C, C++, and Java, and have used Java for most of my professional career. Very early in my research, I ran across a bunch of articles of the type “Why Rust is better than <insert programming="" language="" here="">" and "Why you should learn Rust." They all seem to have come from the same root source – and mostly cover points that any statically typed language that doesn't run on a virtual machine runtime would have. "Blazingly fast" "catches variable type mismatch at compile time" are examples.</insert></p>

<p>What is missing is an explanation of what is unique to Rust that other languages do not have. I want to tackle the first reason in this article – the Rust Borrow Checker.</p>

<p>The inventors of Rust benefit from years of practical experience with other programming languages. They have designed a set of features in the language and associated tooling that address many of the pain points facing application developers. First up is memory management – from the beginning, programs have dealt with how to use memory safely, and the Rust Borrow Checker is a novel approach to solving this problem.</p>

<h2 id="some-history">Some history</h2>

<p>First, let me review some history of how programming languages have tried to tackle this problem. In the beginning, there was C, and the low-level and often-cursed “malloc()” and “free().” C is a programming language that gives developers complete control of their environment – it is a small step up from assembly language. Developers get to fully manage memory access for their application and how to give allocated memory back to the operating system. This low-level control takes a lot of careful planning. But, it was the source of many runtime errors, through either memory leaks (not letting go of memory) or crashes (freeing the same pointer twice or using memory after it is released are common problems). It is also a source of security issues – reading previously freed memory for data you’re not supposed to have is a possible exploit. Here’s an example program that demonstrates what the compiler allows but is incorrect:</p>

<h3 id="c-code">C Code</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="cp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="o">*</span><span class="nf">get_me_some_memory</span><span class="p">(</span><span class="kt">int</span> <span class="n">how_much</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">how_much</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">my_memory</span> <span class="o">=</span> <span class="n">get_me_some_memory</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
  
  <span class="n">my_memory</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
  <span class="n">my_memory</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="c1">// Note, access beyond the end of my allocation</span>

  <span class="n">free</span><span class="p">(</span><span class="n">my_memory</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">bad_value</span> <span class="o">=</span> <span class="n">my_memory</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// Note, access to memory after a free  </span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bad_value</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">*</span> <span class="n">Output</span> <span class="n">of</span> <span class="n">the</span> <span class="n">above</span> <span class="n">when</span> <span class="n">compiled</span> <span class="n">and</span> <span class="n">executed</span><span class="p">,</span> <span class="n">MacOs</span>
<span class="o">&gt;</span> <span class="n">cc</span> <span class="n">c</span><span class="o">-</span><span class="n">malloc</span><span class="o">-</span><span class="n">example</span><span class="p">.</span><span class="n">c</span>
<span class="o">&gt;</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span>
<span class="o">&gt;</span> <span class="mi">12</span>

<span class="o">*</span> <span class="n">Same</span> <span class="n">source</span> <span class="n">code</span><span class="p">,</span> <span class="n">compiled</span> <span class="n">with</span> <span class="n">compiler</span> <span class="n">optimizations</span> <span class="n">turned</span> <span class="n">on</span><span class="o">:</span>
<span class="o">&gt;</span> <span class="n">cc</span> <span class="o">-</span><span class="n">Ofast</span> <span class="n">c</span><span class="o">-</span><span class="n">malloc</span><span class="o">-</span><span class="n">example</span><span class="p">.</span><span class="n">c</span>
<span class="o">&gt;</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span>
<span class="o">&gt;</span> <span class="mi">0</span>
</code></pre></div></div>

<p>C++ enabled better control over memory allocation – classes had constructors that would allocate memory for their objects, and destructors freed that memory. Smart Pointers also were created that helped with automatically freeing memory when variables fell out of scope. But the “foot guns” of low-level pointers and references made errors challenging to eliminate. You were ok if you followed the rules – but if you weren’t aware of the rules, the compiler wasn’t of any help. The hidden complexity inside objects also made it difficult to follow the rules and predict how your application would perform.</p>

<h2 id="garbage-collection">Garbage Collection</h2>

<p>Programming languages turned to garbage collection as a means to solve these problems. Garbage collection-based programs can grab whatever memory they need from a runtime environment. In the background, the garbage collection process will release memory back to the operating system once the program is no longer using it. Scripting languages that rely on interpreting source code at run time, including Basic, Python, and JavaScript, use this approach in the run time environment of their interpreters. Java was one of the first compiled languages that targeted running within a runtime (the JVM) that performed garbage collection. New programming languages, including Golang (Go) and Dart, utilize Garbage Collection. These environments are productive for developers – it makes managing memory much simpler. Garbage collectors have gotten very sophisticated, and many application types work well in this environment.</p>

<p>But Garbage Collection imposes limitations. The overhead imposed by the Garbage Collector impacts the application’s runtime behavior. Pauses in the application need to be scheduled, which makes Garbage Collected languages unsuitable for real-time programming. The runtime that goes along with the environment is also typically heavyweight, which gets in the way when running in the small environments of embedded and IoT devices – or containerized microservices. Here’s a quick example java application that is similar to our C version that shows how garbage collection is useful:</p>

<h3 id="java-code">Java Code</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">java_allocation_example</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
        
          <span class="kt">int</span> <span class="o">[]</span><span class="n">my_memory</span> <span class="o">=</span> <span class="n">get_me_some_memory</span><span class="o">(</span><span class="mi">25</span><span class="o">);</span>
          
          <span class="n">my_memory</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span>  <span class="c1">// Completely normal and valid</span>
          <span class="n">my_memory</span><span class="o">[</span><span class="mi">30</span><span class="o">]</span> <span class="o">=</span> <span class="mi">15</span><span class="o">;</span> <span class="c1">// Note, access beyond the end of my allocation, this blows up in Java</span>
        
          <span class="kt">int</span> <span class="o">[]</span><span class="n">my_new_memory</span> <span class="o">=</span> <span class="n">my_memory</span><span class="o">;</span> <span class="c1">// I have a new variable - does this get a copy, or does it just</span>
                                           <span class="c1">// point to the original?</span>

          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Initial value: "</span> <span class="o">+</span> <span class="n">my_memory</span><span class="o">[</span><span class="mi">5</span><span class="o">]);</span> <span class="c1">// Still 12, as it should be</span>

          <span class="n">my_new_memory</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span> <span class="c1">// using my 2nd variable to update the array</span>

          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New value: "</span> <span class="o">+</span> <span class="n">my_new_memory</span><span class="o">[</span><span class="mi">5</span><span class="o">]);</span> <span class="c1">// This prints out "7", my new value</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original array: "</span> <span class="o">+</span> <span class="n">my_memory</span><span class="o">[</span><span class="mi">5</span><span class="o">]);</span> <span class="c1">// What does this print???</span>
          
          <span class="n">my_memory</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// Doesn't free anything, but the GC could now reclaim our memory if</span>
                            <span class="c1">// it wanted to.</span>
                            
          <span class="c1">//Will cause a null pointer exception.</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Use after null: "</span> <span class="o">+</span> <span class="n">my_memory</span><span class="o">[</span><span class="mi">5</span><span class="o">]);</span> 
          
          <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get_me_some_memory</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span> 
    <span class="o">}</span>   
<span class="o">}</span>

<span class="o">*</span> <span class="nc">Terminal</span> <span class="nl">execution:</span>
<span class="o">&gt;</span> <span class="n">java</span> <span class="n">java_allocation_example</span><span class="o">.</span><span class="na">java</span>
<span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ArrayIndexOutOfBoundsException</span><span class="o">:</span> <span class="nc">Index</span> <span class="mi">30</span> <span class="n">out</span> <span class="n">of</span> <span class="n">bounds</span> <span class="k">for</span> <span class="n">length</span> <span class="mi">25</span>
        <span class="n">at</span> <span class="n">java_allocation_example</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">java_allocation_example</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">7</span><span class="o">)</span>

<span class="o">*</span> <span class="n">after</span> <span class="n">all</span> <span class="n">bad</span> <span class="n">lines</span> <span class="n">are</span> <span class="n">commented</span> <span class="nl">out:</span>        
<span class="o">&gt;</span> <span class="n">java</span> <span class="n">java_allocation_example</span><span class="o">.</span><span class="na">java</span>
<span class="nc">Initial</span> <span class="nl">value:</span> <span class="mi">12</span>
<span class="nc">New</span> <span class="nl">value:</span> <span class="mi">7</span>
<span class="nc">Original</span> <span class="nl">array:</span> <span class="mi">7</span>

</code></pre></div></div>

<p>Everything compiles, but we get consistent crashes at run time instead of undefined runtime behavior – that’s good and bad. Predictable behavior is good, but the java “NullPointerException” runtime error has crashed applications in production more times than anyone would want to admit. When we comment out the bad line, we now see a side effect – the new variable did not receive a completely new version of the array; it just “pointed” to the original. When we modified the new variable, the original one had its contents modified out from under it. In this trivial example, we can follow what is happening here – but if that modification occurred deep within a nested library function, we could easily be surprised.</p>

<p>But, our memory management is more straightforward – we get to request the memory space we need at run time and don’t have to deal with letting it go. The ease of use is why garbage collection is widespread, and mainstream languages JavaScript, Python, Go, and Dart are using it today.</p>

<h2 id="what-rust-does-differently">What Rust does differently</h2>

<p>Rust’s approach to memory management enables the ease of memory management of a Garbage Collection environment <em>but without the runtime environment overhead or associated performance penalty</em>. It also solves the unexpected side effect problems we saw in our Java example. A smart pointer-style mechanism is a key – but instead of relying on programmers to follow usage rules (like C++), the compiler enforces access rules. “Fighting the borrow checker” is one of the first things new Rust developers figure out how to do – but once mastered, it enables developers to manage their memory usage automatically.</p>

<p>Along with a productive development environment, Rust’s borrow checker eliminates a whole class of programming errors related to memory management. Surveys have demonstrated that many of the security vulnerabilities present in applications are due to a program’s inability to protect access to allocated memory. Rust programs run fast, enable developers to be efficient, are more secure, and reduce runtime crashes. Let’s look at a Rust application that mimics our examples:</p>

<h3 id="finally---some-rust-code">Finally - some Rust code!</h3>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">fn</span> <span class="nf">get_me_some_memory</span><span class="p">(</span><span class="n">how_much</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">how_much</span><span class="p">]</span>   <span class="c">//Rust fun - can skip the "return" when skipping the trailing ;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">some_vector</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">my_vector</span> <span class="o">=</span> <span class="nf">get_me_some_memory</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">my_array</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">50</span><span class="p">];</span>

    <span class="n">my_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c">// Completely normal and valid</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">55</span><span class="p">]</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span> <span class="c">// Going off the deep end of the array - this blows up at</span>
                       <span class="c">// compile time, not run time.</span>
    <span class="n">my_vector</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="c">// A dynamic vector makes it through a compile, but panics at</span>
                        <span class="c">// run time.</span>

    <span class="n">some_vector</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">;</span> <span class="c">//typical assigning to a new variable - or is it?</span>

    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">some_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c">// Look the vector moved to its new home, everything works</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

    <span class="n">some_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="c">// I can re-assign my value just fine.</span>

    <span class="k">let</span> <span class="n">old_value</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c">// This doesn't compile - my_vector is no longer valid here</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">old_value</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We again have a function that allocates a block of memory on the heap using Rust’s Vector type. A Vector is a contiguous block of memory that is dynamically sized, accessed like an array, and stored on the heap. By contrast, line 8 allocates an array, which is fixed in size at compile time and allocates on the stack. Since we know the array size at compile time, we get a compiler warning on line 12 – Rust knows that we’re going past the end of the array.</p>

<h3 id="rusts-compiler-keeps-us-safe">Rust’s compiler keeps us safe</h3>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">&gt;</span> <span class="n">cargo</span> <span class="n">build</span>
   <span class="n">Compiling</span> <span class="n">rust_examples</span> <span class="n">v0</span><span class="na">.1.0</span> 
<span class="n">error</span><span class="p">:</span> <span class="n">this</span> <span class="n">operation</span> <span class="n">will</span> <span class="n">panic</span> <span class="n">at</span> <span class="n">runtime</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="err">\</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">5</span>
   <span class="p">|</span>
<span class="mi">12</span> <span class="p">|</span>     <span class="n">my_array</span><span class="p">[</span><span class="mi">55</span><span class="p">]</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span> <span class="c">// Going off the end of the array - this blows up </span>
   <span class="p">|</span>     <span class="o">^^^^^^^^^^^^</span> <span class="n">index</span> <span class="n">out</span> <span class="n">of</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">the</span> <span class="n">length</span> <span class="n">is</span> <span class="mi">50</span> <span class="n">but</span> <span class="n">the</span> <span class="n">index</span> <span class="n">is</span> <span class="mi">55</span>
   <span class="p">|</span>
   <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="err">`</span><span class="nd">#[deny(unconditional_panic)]</span><span class="err">`</span> <span class="n">on</span> <span class="n">by</span> <span class="n">default</span>

<span class="n">error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">rust_examples</span><span class="err">`</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>


<span class="o">*</span> <span class="n">Commenting</span> <span class="n">out</span> <span class="n">the</span> <span class="nf">array</span> <span class="p">(</span><span class="n">lines</span> <span class="mi">8</span> <span class="n">and</span> <span class="mi">12</span><span class="p">),</span> <span class="n">we</span> <span class="n">now</span> <span class="n">get</span> <span class="n">another</span> <span class="n">error</span><span class="p">:</span>
<span class="o">&gt;</span> <span class="n">cargo</span> <span class="n">build</span>
   <span class="n">Compiling</span> <span class="n">rust_examples</span> <span class="n">v0</span><span class="na">.1.0</span> 
<span class="n">error</span><span class="p">[</span><span class="n">E0382</span><span class="p">]:</span> <span class="n">borrow</span> <span class="n">of</span> <span class="n">moved</span> <span class="n">value</span><span class="p">:</span> <span class="err">`</span><span class="n">my_vector</span><span class="err">`</span>
  <span class="o">-</span><span class="k">-&gt;</span> <span class="n">src</span><span class="err">\</span><span class="n">main</span><span class="py">.rs</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">21</span>
   <span class="p">|</span>
<span class="mi">7</span>  <span class="p">|</span>     <span class="k">let</span> <span class="k">mut</span> <span class="n">my_vector</span> <span class="o">=</span> <span class="nf">get_me_some_memory</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
   <span class="p">|</span>         <span class="o">-------------</span> <span class="k">move</span> <span class="n">occurs</span> <span class="n">because</span> <span class="err">`</span><span class="n">my_vector</span><span class="err">`</span> <span class="n">has</span> <span class="k">type</span> <span class="err">`</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="err">`</span><span class="p">,</span> <span class="n">which</span> <span class="n">does</span> <span class="n">not</span> <span class="n">implement</span> <span class="n">the</span> <span class="err">`</span><span class="nb">Copy</span><span class="err">`</span> <span class="k">trait</span>
<span class="o">...</span>
<span class="mi">16</span> <span class="p">|</span>     <span class="n">some_vector</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">;</span> <span class="c">//typical assigning to a new variable - or is it?</span>
   <span class="p">|</span>                   <span class="o">---------</span> <span class="n">value</span> <span class="n">moved</span> <span class="n">here</span>
<span class="o">...</span>
<span class="mi">23</span> <span class="p">|</span>     <span class="k">let</span> <span class="n">old_value</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c">// This doesn't compile - my_memory is no longer valid here</span>
   <span class="p">|</span>                     <span class="o">^^^^^^^^^</span> <span class="n">value</span> <span class="n">borrowed</span> <span class="n">here</span> <span class="n">after</span> <span class="k">move</span>

<span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">this</span> <span class="n">error</span><span class="p">,</span> <span class="n">try</span> <span class="err">`</span><span class="n">rustc</span> <span class="o">--</span><span class="n">explain</span> <span class="n">E0382</span><span class="err">`</span><span class="py">.
error</span><span class="p">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">compile</span> <span class="err">`</span><span class="n">rust_examples</span><span class="err">`</span> <span class="n">due</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">error</span>
</code></pre></div></div>

<p>The rust compiler is excellent at giving us meaningful error information. On line 16, the vector is “moved” to a new home – it no longer exists at my_vector. Rust keeps track of the allocated memory but ensures that only one variable “owns” the memory and can make changes.</p>

<p>We can assign a variable to our vector if we state it is an immutable variable. We can only “read” the values through this new variable, not write to them. Rust enforces a rule that there can only be 1 “writer” / “owner” at a time – that way, it prevents all “whoever saves last wins” errors, the unexpected side effect issues we saw in our Java example. It can also keep track of the variables using the allocated memory to ensure it gets freed when all of the variables using the memory fall out of scope. Here’s our example program with an immutable variable pointing to our vector:</p>

<h3 id="updated-listing-showing-borrowing-with-an-immutable-variable">Updated listing, showing borrowing with an immutable variable</h3>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">some_vector</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">my_vector</span> <span class="o">=</span> <span class="nf">get_me_some_memory</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
    <span class="c">//let mut my_array: [usize; 50] = [0; 50];</span>
    <span class="k">let</span> <span class="n">my_read_only_pointer</span><span class="p">;</span> <span class="c">//notice no "mut" here, we cannot write values</span>
                              <span class="c">//using this variable, only read them</span>

    <span class="n">my_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c">// Completely normal and valid</span>
    <span class="c">//my_array[55] = 17; // Going off the deep end of the array - this blows up at</span>
                       <span class="c">// compile time</span>
    <span class="n">my_vector</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="c">// A dynamic vector makes it through compile, but panics at</span>
                        <span class="c">// run time</span>

    <span class="n">my_read_only_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_vector</span><span class="p">;</span> <span class="c">// Borrowing access to the vector</span>
    <span class="k">let</span> <span class="n">abc</span> <span class="o">=</span> <span class="n">my_read_only_pointer</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">abc</span><span class="p">);</span>

    <span class="n">some_vector</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">;</span> <span class="c">//typical assigning to a new variable - or is it?</span>

    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">some_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c">// Look the vector moved to its new home, everything works</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

    <span class="n">some_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="c">// I can re-assign my value just fine.</span>
    
    <span class="k">let</span> <span class="n">old_value</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c">// This doesn't compile - my_memory is no longer valid here</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">old_value</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="the-magic-of-rusts-borrow-checker-is-this">The magic of Rust’s borrow checker is this:</h2>

<ol>
  <li>Rust ensures ownership of any memory (heap or stack) is in one place. Only the owner of the data can manipulate it. Multiple read-only access is allowed.</li>
  <li>Rust keeps track of the memory variables used and automatically frees up memory when all the variables using that memory are out of scope – whether on the stack (our array example) or the heap (our Vector example).</li>
  <li>Bounds checking is enforced either at compile time (for arrays, which have their sizes determined at compile time) or run time (vectors, which have their sizes set at run time).</li>
  <li>These rules eliminate a whole class of errors and security vulnerabilities. We can’t write to memory after a free() – Rust keeps memory around for us as long as anything has access. These rules are all checked at compile time. We don’t have to worry about letting go of memory – Rust takes care of that. Boundary checks also prevent us from writing outside of the memory space allocated to us.</li>
  <li>Most of this happens at compile time – we do not have a runtime garbage collector that has to run alongside us, and there are no interruptions to the program execution to allow a garbage collector to interrogate memory usage. A common Rust saying is: “if it compiles, it will work.”</li>
</ol>

<p>Even better, how the borrow checker works enable multiple threads to use allocated memory safely. When programs move into multiple threads of execution, the opportunity for error expands exponentially. “Fearless concurrency” – using data safely across multiple threads automatically – is a significant benefit of Rust’s borrow checker.</p>

<p>Rust’s memory management and the borrow checker are two main reasons Rust is different. You can access memory at a low level with complete control, without a garbage collector runtime or the risks of a runtime error blowing up your program unexpectedly. This feature makes Rust great for low-level systems, embedded, or real-time applications where efficiency is necessary. It also enables Rust to be used for higher-level applications such as web service publishing, as the “memory automatically frees” environment is productive for developers.</p>

<p>But that’s not all – follow me to be notified when I publish the next article on another feature of Rust that makes it great!</p>

    <div>Want to encourage more content like this? Please consider <a
            href="https://www.buymeacoffee.com/mikehentges">buying me a cup of coffee!</a>
        <p></p>
    </div>
</section> <!-- This is our footer. -->
<footer>
  <div class="footer-bottom">
    <div class="author">Michael Hentges Blog © 2022</div>
    <div class="author">
      <a rel="me" href="https://hachyderm.io/@mhentges">Mastodon</a>
    </div>
    <div class="tool">
      Powered by <a href="https://jekyllrb.com/">Jekyl</a> and
      <a href="https://pages.github.com/">GitHub Pages</a>
    </div>
  </div>
</footer>

  </body>
</html>
